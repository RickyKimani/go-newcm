//go:build ignore
// +build ignore

package main

import (
	"archive/zip"
	"flag"
	"fmt"
	"io"
	"log"
	"net/http"
	"os"
	"path"
	"path/filepath"
	"regexp"
	"strings"
)

const suffix = ".otf"

func main() {
	log.SetPrefix("newcm-gen: ")
	log.SetFlags(0)

	var src = flag.String("src", "https://mirrors.ctan.org/fonts/newcomputermodern.zip", "remote ZIP file holding OTF files for New Computer Modern fonts")
	flag.Parse()

	tmp, err := os.MkdirTemp("", "go-newcm-")
	if err != nil {
		log.Fatalf("could not create tmp dir: %v", err)
	}
	defer os.RemoveAll(tmp)

	var zr *zip.ReadCloser
	if strings.HasPrefix(*src, "https://") {
		zr, err = fetch(tmp, *src)
		if err != nil {
			log.Fatalf("could not fetch fonts: %v", err)
		}
	} else {
		zr, err = zip.OpenReader(*src)
		if err != nil {
			log.Fatalf("could not open zip: %v", err)
		}
	}
	defer zr.Close()

	for _, f := range zr.File {
		if !strings.HasSuffix(f.Name, suffix) || strings.Contains(f.Name, "__MACOSX") {
			continue
		}

		err := gen(f)
		if err != nil {
			log.Fatalf("failed to generate for %s: %v", f.Name, err)
		}
	}
}

func fetch(tmp, src string) (*zip.ReadCloser, error) {
	resp, err := http.Get(src)
	if err != nil {
		return nil, fmt.Errorf("GET failed: %w", err)
	}
	defer resp.Body.Close()

	outPath := path.Join(tmp, "newcm.zip")
	out, err := os.Create(outPath)
	if err != nil {
		return nil, err
	}
	defer out.Close()

	_, err = io.Copy(out, resp.Body)
	if err != nil {
		return nil, err
	}

	return zip.OpenReader(outPath)
}

func gen(f *zip.File) error {
	rc, err := f.Open()
	if err != nil {
		return fmt.Errorf("open failed: %w", err)
	}
	defer rc.Close()

	src, err := io.ReadAll(rc)
	if err != nil {
		return fmt.Errorf("read failed: %w", err)
	}

	fontName := path.Base(f.Name)
	pkg := pkgName(fontName)

	dir := filepath.Join(".", pkg)
	err = os.MkdirAll(dir, 0755)
	if err != nil {
		return fmt.Errorf("mkdir failed: %w", err)
	}

	otfPath := filepath.Join(dir, fontName)
	err = os.WriteFile(otfPath, src, 0644)
	if err != nil {
		return fmt.Errorf("failed to write OTF: %w", err)
	}

	fontDisplayName := displayName(fontName)
	goCode := fmt.Sprintf(`// Code generated by go generate; DO NOT EDIT.

// Package %s provides the "%s" TrueType font
// from the New Computer Modern font family.
package %s // import "github.com/rickykimani/go-newcm/%s"

import _ "embed"

// Font is the data for the "%s" TrueType font.
//
//go:embed %s
var Font []byte
`, pkg, fontDisplayName, pkg, pkg, fontDisplayName, fontName)

	err = os.WriteFile(filepath.Join(dir, "data.go"), []byte(goCode), 0644)
	if err != nil {
		return fmt.Errorf("failed to write data.go: %w", err)
	}

	log.Printf("generated %s â†’ %s/", fontName, pkg)
	return nil
}

func pkgName(name string) string {
	name = strings.TrimSuffix(name, ".otf")
	name = strings.ToLower(name)
	name = regexp.MustCompile(`[^a-z0-9]+`).ReplaceAllString(name, "")
	if name == "" || (name[0] >= '0' && name[0] <= '9') {
		name = "font" + name
	}
	return name
}

func displayName(fontFile string) string {
	name := strings.TrimSuffix(fontFile, ".otf")
	name = strings.ReplaceAll(name, "-", " ")
	name = strings.ReplaceAll(name, "_", " ")
	return name
}
